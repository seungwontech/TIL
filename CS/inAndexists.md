## 서브쿼리 사용 시 발생하는 문제점

- 서브쿼리는 가독성이 좋을 수 있지만, 성능 문제를 유발할 수 있다.

1. 비효율적인 실행 계획
    - 서브쿼리는 메인 쿼리와 독립적으로 실행되며 최적화가 어렵다.
    - `in(select ...)` 같은 서브쿼리는 메인 쿼리 실행 시마다 서브쿼리가 반복 실행될 수 있다.
2. 불필요한 중복 연산
    - 서브쿼리는 메인 쿼리와 별도로 연산되므로 같은 데이터를 여러번 스캔할 수 있다.
3. 인덱스 활용 부족
    - `in(select ...)` 서브쿼리는 옵티마이저가 인덱스를 효율적으로 활용하기 어렵다.
    - 반면 `join`을 사용하면 테이블 간의 관계를 활용하여 인덱스 조회가 더 효율적이다.

### IN (SELECT ...) 서브쿼리 (비효율적인 서브 쿼리 사용)

```
SELECT * FROM user WHERE id IN (SELECT user_id FROM order WHERE order_date > SYSDATE - 30);
```

- 문제점 `user` 테이블을 조회할 때마다 `order` 테이블을 반복 조회
- orders 테이블에서 `user_id`를 추출하는 과정에서 인덱스를 잘 활용하지 못할수 있음
- `user` 테이블의 건수가 많으면 성능 저하 발생

### JOIN을 활용한 개선

```
SELECT DISTINCT u.* FROM user u JOIN order o ON u.id = o.user_id WHERE o.order_date > SYSDATE - 30;
```

- JOIN을 사용하면 두 테이블을 한 번만 조회하므로 성능 향상
- 인덱스가 존재하면 최적화 가능(orders.user_id에 인덱스가 있다면 빠르게 조회)
- `distinct`를 사용하여 `JOIN`으로 인해 중복된 데이터를 제거(필요시)

### EXISTS를 활용한 최적화

- `EXISTS`는 특정 조건을 만족하는 행이 존재하는지 여부만 확인하므로 `JOIN`보다 더 효율적일 때도 있음.
- `IN`서브쿼리는 결과를 메모리에 저장하고 이를 메인 쿼리와 비교하는 방식이므로 대량 데이터에서는 성능이 저하될 수있음.

```
SELECT * FROM user u WHERE EXISTS (
    SELECT 1 FROM order o 
    WHERE o.user_id = u.id 
    AND o.order_date > SYSDATE - 30
);
```

- `EXISTS`는 서브쿼리의 첫 번째 일치하는 행을 찾으면 즉시 종료(불필요한 조회 방지).
- `JOIN`보다도 불필요한 데이터 조회를 줄일 수 있음.
- `user`의 개수가 많고 `order`에 `user_id` 인덱스가 있다면 성능 향상 효과가 큼.

### 최적 선택 방법

- 결과 데이터가 많다면 `JOIN`을 사용
- 대상 테이블이 크고 특정 조건을 만족하는지 여부만 확인한다면 `EXISTS`가 더 유리
- `exists`도 서브쿼리지만 실행 방식이 최적화되어 있어 일반 `in` 서브쿼리보다 빠를 수 있음.

## NOT IN vs NOT EXISTS 최적화

### NOT IN 사용시 문제점

- `NULL` 값을 포함할 경우 올바른 결과를 반환하지 않음

### NOT EXISTS

- `NULL`을 고려할 필요 없이 정상적을 동작
- 불필요한 조회를 하지 않으며 존재 여부만 확인하면 즉시 종료
- 테이블 크기가 클수록 NOT `EXISTS`가 더 효율적


## 서브쿼리의 성능 저하 이유

1. 전체 테이블 스캔 발생
    - 서브쿼리는 먼저 실행되어 모든 결과를 생성한 후 메인 쿼리에서 비교
    - 데이터가 많을수록 성능 저하가 심각해짐
2. 서브쿼리마다 반복 실행
    - `IN`이나 `NOT IN`을 사용할 경우 메인 쿼리의 각 행마다 서브쿼리가 실행됨
    - EXISTS는 첫 번째 매칭 데이터만 확인하지만 `IN`은 전체 결과를 로드해야 함
3. 인덱스 활용 어려움
    - 서브쿼리 결과가 임시 테이블로 저장되어 인덱스가 적용되지 않는 경우가 많음
    - 특히 `NOT IN`은 NULL 문제로 최적화가 어려움
4. 메모리 사용량 증가
    - 서브쿼리 결과가 크면 메모리에 전체 데이터를 저장해야 하므로 메모리 부담이 커짐
5. 조인보다 최적화 부족
    - `JOIN`은 한 번의 테이블 스캔으로 해결 가능하지만, 서브쿼리는 별도의 추가 연산이 필요하여 느림