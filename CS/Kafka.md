# kafka

- 분산형 스트리밍 플랫폼으로 대용량 데이터 스트리밍을 처리하기 위해 설계
- 데이터를 실시간으로 처리 저장, 그리고 전송하는데 특화된 시스템

## 동작 원리

프로듀서, 컨슈머, 브러커, 토픽, 파티션 등 여러 구성요소를 기반으로한다.

- 프로듀서(Producer)
    - 카프카에서 데이터를 생성하는 클라이언트로 데이터를 토픽에 기록한다.
    - `데이터를 생성하여 토픽에 기록하는 역할`
    - 여러 프로듀서가 동시에 데이터를 전송할 수 있다.
- 컨슈머(Consumer)
    - 데이터를 토픽에서 `읽는 역할`을 하는 클라이언트
    - 컨슈머 그룹 단위로 운영되어 여러 컨슈머가 독립적으로 데이터 처리 가능
- 브러커(Broker)
    - 카프카의 `서버 역할`로, 데이터를 저장하고 클라이언트와 연결되는 역할 한다.
    - 카프카 클러스터는 여러 개의 브로커로 구성되며, 브로커들 간에 `데이터가 분산 저장`된다.
    - 클러스터 내에서 데이터가 복제된다.
    - 브로커는 클러스터 내에서 파티션을 분산 저장하고 데이터를 안정적으로 처리할 수 있도록 한다.
- 토픽(Topic)
    - `데이터를 저장하는 논리적 단위`
    - 파티션은 병렬 처리를 가능하게 하여 높은 확장성을 제공한다.
    - 각 파티션은 단일 순차 로그로 구성되어 있으며, 파티션 내에서 메시지는 순서대로 저장된다.
    - 파티션은 분산 환경에서 데이터를 분산시켜 저장하며, 각 파티션에서 고유한 오프셋이 있다.
- 파티션
    - `토픽 내에서 데이터를 물리적으로 나누는 단위`
    - `병렬 처리`가 가능하도록 데이터를 여러 파티션으로 나누어 저장
    - 파티션 내부에서 `데이터는 순서 보장`
    - 각 파티션은 오프셋(데이터의 위치를 정보)을 가짐
    - 브로커에 여러 개의 파티션이 분산 저장되며 리더 파티션과 팔로워 파티션으로 복제 가능
    - 컨슈머는 특정 파티션을 읽으며 같은 컨슈머 그룹 내에서는 하나의 파티션을 한 컨슈머만 읽음.
- 컨슈머 그룹
    - 여러 컨슈머로 구성된 그룹
    - 각 컨슈머는 그룹 내에서 파티션을 분담하여 데이터를 읽는다.
    - 하나의 파티션은 한번에 하나의 컨슈머에 의해 읽히지만 여러 컨슈머 그룹이 같은 토픽을 병렬로 처리한다.
- zookeeper
    - `카프카 클러스터의 메타데이터 및 상태 관리` 담당
    - `브로커의 상태와 파티션의 리더 등의 정보를 저장`
    - zookeeper는 카프카의 높은 가용성을 지원한다.
    - 카프카 클러스터의 리더 브로커가 장애가 발생할 경우 새로운 리더를 선출하는 역할을 한다.
    - (카프카 2부터 kraft모드로 zookeeper 의존도를 줄인다.)
- 카프카 클러스터
    - 여러 개의 브로커가 모여서 하나의 분산 메시징 시스템을 이루는 구조입니다.
    - 데이터를 안정적으로 저장하고 높은 처리량을 지원하기 위해 다수의 브로커로 구성

## 동작 원리

1. 메시지 생성(Producer)
    - 프로듀서는 카프카 클러스터의 특정 토픽에 데이터를 보낸다. 데이터는 메시지로 표현되며,   
      카프카에 전송되는 각 메시지는 해당 토픽의 파티션에 기록된다.
    - 프로듀서는 메시지를 어떤 파티션에 보낼지 결정하는 방법을 설정할수 있다.(키 기반 해싱, 라운드 로빈 방식 등)
2. 메시지 저장(Broker)
    - 카프카의 브로커는 프로듀서가 보낸 메시지르 파티션에 저장한다.
    - 각 파티션은 로그 파일 형태로 메시지를 순차적으로 저장한다. 각 메시지는 고유한 오프셋을 가지며,   
      이를 통해 메시지의 순서를 추적할 수 있다.
    - 파티션은 여러 브로커에 분산되어 저장될 수 있으며, 데이터를 복제하여 내결함성을 보장한다.
3. 메시지 소비(Consumer)
    - 컨슈머는 특정 토픽의 파티션에서 메시지를 읽는다.
    - 각 파티션은 하나의 컨슈머에 의해만 읽히며, 컨슈머는 오프셋을 기준으로 메시지를 읽는다.
    - 오프셋은 카프카 내에서 각 메시지가 저장된 위치를 나타낸다.
    - 컨슈머는 자신의 오프셋을 저장하며, 중단된 지점에서 데이터를 계속 읽을 수 있다.
    - 컨슈머 그룹 내에서 컨슈머들은 파티션을 분담하여 읽기 때문에, 한 컨슈머가 여러 파티션을 병렬로 처리한다.
4. 메시지 전달
    - 메시지는 프로듀서에서 카프카 브로커를 통해 컨슈머에게 전달된다.
    - 컨슈머는 메시지를 소비한 후, 오프셋을 업데이트한다. 이렇게 함으로써,  
      메시지가 중복되지 않고 순차적으로 소비된다.

### 전체적인 흐름 정리

1. `프로듀서`가 메시지를 `토픽`에 전송한다.
2. `브로커`는 `프로듀서`가 보낸 메시지를 받아 `파티션`에 저장한다.
3. `컨슈머`는 `브로커`에 저장된 메시지를 `오프셋`을 기준으로 읽는다.
4. `컨슈머`는 메시지를 `소비`하며 처리된 위치(`오프셋`)를 갱신한다.

## 오프셋(Offset)?

- Kafka에서 메시지가 저장된 위치를 나타내는 번호

### 중요한 이유

- 데이터 재처리 가능: 컨슈머가 특정 오프셋을 지정하면, 원하는 위치부터 다시 메시지를 읽을 수 있음.
- 확장성과 병렬처리: 컨슈머 그룹을 활용하면 여러 컨슈머가 서로 다른 파티션의 오프셋을 관리하며 병렬 처리 가능.
- 중복 처리 방지: 컨슈머가 마지막으로 읽은 오프셋을 저장하면, 중복 없이 이어서 처리 가능.

### 오프셋 정리

- 오프셋(Offset)은 Kafka에서 메시지가 저장된 위치를 나타내는 고유한 번호이며,
- 컨슈머는 오프셋을 기준으로 메시지를 읽고 처리하며,
- 오프셋을 저장(commit)하면 이후에도 중단된 위치에서 이어서 읽을 수 있음.


 