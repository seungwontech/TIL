## RDB와 NoSQL DB의 차이점을 설명

RDB는 테이블 기반의 정형화된 데이터 구조를 같고, NoSQL은 테이블 형식이 아닌 비정형 데이터를 저장한다.  
RDB는 엄격한 스키마로 인해 데이터 중복이 없기 때문에 업데이트가 많을 때 유리하고 NoSQL은 데이터의 중복으로   
인해 업데이트 시 모든 컬렉션에서 수정 필요하기 때문에 업데이트가 적고 조회가 많을 때 유리합니다.

NoSQL의 특징은 ACID, 트랜잭션을 지원하지 않는다. RDB는 ACID와 트랜잭션을 보장하기 위해 수평적 확장이 쉽지 않다.  
멀티 서버로 수평적 확장이 가능하지만 하게 되면 조인을 하기 위해 상당히 복잡한 과정이 필요하다.  
RDB를 수평적 확장하기 위해선 샤딩이 필요하다. ACID 준수를 유지하면서 RDB를 샤딩하는 것은 매우 까다로운작업이다.

> 정리하자면, RDB는 데이터 구조가 명확하고 변경될 일이 없는 경우,  
> 데이터의 중복이 없어 데이터 업데이트가 잦은 시스템에 사용하면 좋다.  
> NoSQL은 정확한 데이테 구조가 정해지지 않은 경우,  
> 데이터의 업데이트가 자주 발생하지 않고 조회가 많은 경우,  
> scale-out이 가능하므로 데이터 양이 많은 경우에 사용하면 좋다.

## 정규화와 역정규화

정규화는 `데이터의 중복을 최소화하고 무결성을 유지하기 위해 테이블을 분리하는 과정`입니다.  
이는 데이터 일관성을 보장하지만 Join 연산이 증가할 수 있습니다. 반면 역정규화는  
조회 성능을 향상시키기 위해 `중복 데이터를 허용하는 기법`으로, 읽기 속도를 높이지만  
데이터 일관성 유지가 어려워질 수 있습니다.

## 트랜잭션과 ACID 특성

트랜잭션은 데이터베이스에서 하나 이상의 작업을 묶어 하나의 논리적 연산으로 처리하는 단위
> 원자성: 모든 작업이 성공하거나 모두 실패해야 함.  
> 일관성: 트랜잭션 실행 전후 데이터의 무결성이 유지됨.  
> 격리성: 동시에 실행되는 트랜잭션이 서로 영향을 주지 않음.  
> 지속성: 트랜잭션이 성공하면 결과가 영구적으로 저장됨.

## Join의 개념과 사용 사례

Join은 두 개 이상의 테이블을 연결하여 데이터를 조회하는 SQL 연산입니다.

- Inner Join: 일치하는 데이터만 반환
- Left Join: 왼쪽 테이블의 모든 데이터와 일치하는 오른쪽 테이블의 데이터 반환
- Right Join: 오른쪽 테이블의 모든 데이터와 일치하는 왼쪽 테이블의 데이터 반환
- Full Join: 양쪽 테이블의 모든 데이터 반환

## 외래키와 참조 무결성

외래키(FK)는 한 테이블이 다른 테이블의 `기본 키`(PK)를 참조하는 컬럼입니다.  
참조 무결성은 참조된 데이터가 변경 또는 삭제될 때 데이터의 일관성을 유지하는 규칙입니다.
> `외래키를 가진 레코드를 삭제할 수 없도록 설정`하여 무결성을 유지할 수 있습니다.

## 교착 상태 (데드락) 방지 방법

두 개 이상의 트랜잭션이 서로의 자원을 기라디면서 `무한 대기 상태`에 빠지는 현상입니다.
하나라도 만족하지 않으면 발생하지 않습니다.

1. 상호 배제: 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야한다.
2. 점유와 대기: 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야한다.
3. 비선점: 이미 할당된 자원을 강제로 빼앗을 수 없다. 프로세스가 task를 마친 후 리소스를 자발적으로 반환할 때까지 기다려야 한다.
4. 환형 대기: 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

- 트랜잭션이 자원을 접근하는 순서를 정해 교착 상태 방지
- 트랜잭션 수행 시간을 최소화하여 잠금 지속 시간을 줄임
- 타임아웃 설정을 통해 교착 상태 발생 시 강제 종료

## 데이터베이스 샤딩

- 데이터를 여러개의 데이터베이스 서버에 분산 저장하는 기법으로 `대규모 트래픽 처리`와 `수평성 확장`(scale-out)을 제공할 수 있습니다.
- 일반적으로 사용자 ID, 지역, 날짜 등을 기준으로 데이터를 분할하여 특정 서버에만 일부 데이터를 처리하도록 구성합니다.

## DB 파티셔닝과 수평/수직 파티셔닝

- 큰 테이블을 여러 개의 작은 테이블로 나누어 성능을 향상시키는 기법입니다.

> 수평 파티셔닝: `행` 단위로 데이터를 나누어 저장  
> 수직 파티셔닝: `컬럼` 단위로 데이터를 분리(자주 조회되는 컬럼과 그렇지 않은 컬럼을 분리하여 관리)

이 방법을 통해 `쿼리 성능을 최적화`하고 `부하를 분산`할 수 있습니다.

## 인덱스를 사용하는 이유
특정 컬럼의 값을 기반으로 데이터를 `빠르게 검색하기 위해` 사용한다.
### 왜 인덱스를 사용할까?
- 검색 속도 향상: where 조건을 사용한 조회 시 전체 테이블 스캔하지 않고, 인덱스를 통해 빠르게 원하는 데이터를 찾을 수 있음.
- 정렬 속도 향상: order by 절이 있는 경우, 이미 정렬된 인덱스를 활용하면 성능이 좋아짐.
- JOIN 성능 개선: 인덱스를 사용하면 두개 이상의 테이블을 조인할 때 성능이 향상됨.

### 언제 인덱스를 사용하면 좋을까?
1. 데이터가 많은 경우
2. 카디널리티가 높은 경우 즉 중복도가 낮은 컬럼
> email(고유한 값 많음) → 인덱스 적합  
> gender(M,F 두 개의 값만 존재) → 인덱스 부적합