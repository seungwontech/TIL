# SOLID 원칙

- 유지보수 가능하고 확장성 있는 시스템을 만들기 위한 5가지 원칙을 의미합니다.

## 단일 책임 원칙 (SRP)

- 클래스는 하나의 책임만을 자겨야 한다. 그 책임을 완수하는데 집중해야한다.
- 즉 하나의 클래스가 너무 많은 일을 하게 되면 코드가 복잡해지고 변경이 어려워진다.

> 잘못된 예시)
> `User`클래스가 사용자 데이터를 처리하는 것 외에도,  
> 데이터베이스와의 통신 및 파일 처리를 맡고 있다면,  
> 해당 클래스는 여러 책임을 지고 있어 SRP를 위반한 것입니다.
>
> 계선된 예시)
> `User`클래스는 사용자 정보를 관리하는데 집중하고,   
> 데이터베이스와의 통신은 `UserReposity` 클래스가 맡도록 분리합니다.

## 개방 폐쇠 원칙 (OCP)

- 소프트웨어 엔티티는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다.
- 즉 기능 확장할 때 기존 코드를 변경하는 것이 아니라 , 새로운 코드를 추가해야합니다.

> 잘못된 예시)
> `DiscountCalculator` 클래스가 특정 할인 정책을 처리하는 코드가 수정이 필요한  
> 상황이 발생할 때 마다, 기존 클래스를 수정해야한다면 OCP를 위반한 것입니다.
>
> 개선된 예시)
> `DiscountCalculator` 클래스에 새로운 할인 정책을 추가하려면, 기존 코드를 수정  
> 하지 않고, 새로운 할인 클래스를 추가하여 확장합니다.

## 리스코프 치환 원칙 (LSP)

- 자식 클래스는 부모 클래스를 대체할 수 있어야 하며, 자식 클래스의 인스턴스가 부모 클래스를 대체했을 때
- 기존의 동작을 방해하면 안된다.

> 잘못된 예시)
> `Bird` 부모 클래스가 있고 `Penguin` 클래스를 그 자식 클래스로 만들었다면, `Penguin`은 날수 없는데 `Bird` 클래스의 fly() 메서드를    
> 호출할 경우 문제가 발생할 수 있습니다.  
>
> 개선된 예시)
> `Brid` 부모 클래스는 Flyable 인터페이스를 분리하여 날 수 있는 `Brid`와 그렇지 않은 `Bird`를 구분합니다.  
> `Penguin`은 `Flyable` 인터페이스를 구현하지 않도록 합니다.

## 인터페이스 분리 원칙 (ISP)

- 사용하지 않는 메서드를 구현하는 인터페이스를 강요하지 말아야 합니다. 즉 클라이언트가 필요하지 않은 메서드를
- 포함하는 인터페이스는 피해야 하며, 기능에 맞는 작고 구체적인 인터페이스를 제공해야합니다.

> 잘못된 예시)
> `Animal`인터페이스에 `eat()`, `fly()`, `swim()` 메서드를 모두 포함시킨 경우, `Fish`는 `fly` 메서드를   
> 구현해야하므로 `ISP`를 위반하게 된다.
>
> 개선된 예시)
> `Flyable`, `Swimmable`과 같은 작은 인터페이스를 만들어 `Animal` 클래스는 필요한 인터페이스만 구현하도록 한다.

## 의존성 역전 원칙 (DIP)

- 상위 모듈은 하위 모듈에 의존하면 안된다 둘다 추상화에 의존해야합니다. 세부 사항은
- 추상화에 의존해야 하며, 의존성 주입을 통해 의존 관계를 관리해야 합니다.

> 잘못된 예시)
> `car` 클래스가 Engine클래스를 직접 생성하여 의존하고 있다면, Car는 Engine에 의존하게 됩니다.  
> 
> 개선된 예시)
> `car` 클래스는 Engine 인터페이스에 의존하고, 실제 엔진의 구현체는 외부에서 주입 받도록 설계하여 DIP를 준수합니다.
