# N + 1 문제란

- 연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수 만큼 연관관계의 조회 쿼리가 추가로 발생하여
- 데이터를 읽어오는 현상

## 발생 이유

N+1 문제가 발생하는 이유는 JPA가 JPQL을 분석해서 SQL을 생성할 때 글로벌 fetch 전략을
참고하지 않고 오직 JPQL 자체만을 사용해서 입니다.

## fetch Join 해결 방법

> JPQL을 사용하여 DB에서 데이터를 자겨올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법  
> 별도의 메소드를 만들어줘야하며 @Query 어노테이션을 사용해서 `join fetch` 엔티티.연관관계_엔티티 구문을  
> 만들어 주면 된다.

```java
public interface TeamRepository extends JpaRepository<Team, Long> {
    @Query("select t from Team t join fetch t.users")
    List<Team> findAllFetchJoin();
}
```

## n+1문제로 DB가 죽어버리는 문제를 방지하기 위해서 어떻게 해야할까?

> 일단 지연로딩으로 사용하고 성능 최적화가 필요한 부분에서는 Fetch 조인을 사용한다.  
> 하고 기본적으로 Batch size의 값을 1000 이하로 설정한다.

- 그외 연관관계 설정이 필요 없다면 n+1 문제로 인한 DB가 죽을 것을 막기 위해 연관관계를 끊어버리고
  사용하는 것도 방법이다.

## Fetch join과 일반 join의 차이

> Fetch join과 일반 join의 차이는 연관된 엔티티를 즉시 로딩하느냐(Lazy vs. Eager)에 있다.   
> 일반 join은 필터링 용도로 사용되며, 연관된 엔티티를 함께 가져오지 않는다.  
> 반면, Fetch join은 연관된 엔티티를 한 번의 쿼리로 함께 조회하여 N+1 문제를 해결할 수 있지만,   
> 다중 컬렉션 Fetch가 불가능하고 페이징과 함께 사용할 경우 성능 저하가 발생할 수 있다.   
> 따라서 연관 엔티티가 반드시 필요한 경우에만 Fetch join을 사용하고,  
> 불필요한 데이터 로딩을 방지하기 위해 신중히 선택해야 한다.

## 즉시 로딩과 지연 로딩

JPA에서 `Fetch Type`인 `EAGER`, `LAZY`로딩은 `데이터를 가져오는 시점`에 관한 설정입니다.

- `Fetch Type`은 데이터베이스에서 데이터를 가져오는 전략
- `EAGER` 전략은 데이터베이스에서 데이터를 `즉시` 가져와야한다는 `요구사항`이다.
- `LAZY` 전략은 데이터를 처음 사용할 때 느리게 가져오라는 `힌트`이다.

> 즉시 로딩은 데이터를 즉시 가져오라는 전략  
> 지연 로딩은 데이터를 사용할 시점에 데이터를 가져오는 전략입니다.

## 참고자료

https://ksh-coding.tistory.com/146
